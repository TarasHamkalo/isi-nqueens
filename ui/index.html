<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>N-Queens Problem</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

<h1 style="text-align: center;">N-Queens Problem Visualizer</h1>
<div class="container">

    <div id="solver-pickers" class="controls controls-left">
<!--        <button id="solveButton">DFS</button>-->
<!--        <button id="solveButton1">Backtracking</button>-->
<!--        <button id="solveButton2">Forward checking</button>-->
    </div>

    <div>
        <div id="board" class="board"></div>
    </div>

    <div id="loading" style="display: none;">Solving...</div>


    <div class="controls controls-right">
        <div class="one-step-button">
            <button id="backwardButton"><<</button>
            <button id="forwardButton">>></button>
        </div>
        <button id="showResult">Final queens positions</button>
        <button id="runButton">Play</button>

        <form id="playbackSpeedForm" action="#" onsubmit="setPlaybackSpeed(event)">
            <label for="playbackSpeed">Playback speed:</label>
            <div style="display: inline-flex; align-items: center;">
                <input type="text" id="playbackSpeed" name="playbackSpeed" placeholder="1000">
                <span style="margin-left: 8px;">ms</span>
            </div>
        </form>

    </div>
</div>

<script>
    const N = 8;
    let actualStep = 0;
    let solutionSteps = [];
    let isRun = false;
    let stepInterval;
    let playbackSpeed = 1000;

    const Methods = {
        DFS: { value: 'dfs', publicName: 'Depth First Search' },
        BACKTRACKING: { value: 'backtracking', publicName: 'Backtracking' },
        FORWARD_CHECKING: { value: 'forwardchecking', publicName: 'Forward checking' },
        MIN_MAX_CONFLICT: { value: 'minmax', publicName: 'Min-Max conflict' },
        HILL_CLIMBING: { value: 'hillclimbing', publicName: 'Hill climbing' }
    };

    document.addEventListener("DOMContentLoaded", () => {
        const board = document.getElementById('board');
        board.style.gridTemplateColumns = `repeat(${N}, 1fr)`;
        initBoard(board);
        defineQueen();

        const solverPickers  = document.getElementById('solver-pickers')
        for (const [key, {value, publicName}] of Object.entries(Methods)) {
            const button = document.createElement('button');
            button.textContent = `Solve using ${publicName}`;
            button.id = `solve${key}`;
            button.addEventListener('click', () => {
                solutionSteps = []
                resetBoard();
                setSolutionSteps(value);
            })

            solverPickers.appendChild(button)
        }

        document.getElementById('forwardButton').addEventListener('click', () => {
            stepForward();
        });

        document.getElementById('backwardButton').addEventListener('click', () => {
            stepBackward();
        });

        document.getElementById("showResult").addEventListener('click', async () => {
            if (isRun) {
                pausePlaying()
            }
            resetBoard()

            setFinalQueensPositions()

        });

        const setFinalQueensPositions = async () => {
            const loadingElement = document.getElementById('loading');
            loadingElement.style.display = 'block';
            await fetch(`http://localhost:5000/board/queens`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                },
            })
                .then((response) => response.json().then(responseSteps => {
                    console.log(responseSteps)
                    responseSteps.forEach((q, c) => queenToggle(c, q))
                    actualStep = solutionSteps.length - 1
                }))
                .then(() => loadingElement.style.display = 'none');
        }

        document.getElementById("playbackSpeed").addEventListener("wheel", (event) => {
            event.preventDefault();

            if (event.deltaY < 0) {
                playbackSpeed += 50;
            } else {
                playbackSpeed = Math.max(0, playbackSpeed - 50);
            }
            document.getElementById("playbackSpeed").value = playbackSpeed;
        });

        document.getElementById('runButton').addEventListener('click', () => {
            isRun = !isRun
            if (isRun) {
                document.querySelector('#runButton').innerText = 'Pause';
                stepInterval = setInterval(safeStepForward, playbackSpeed)
            } else {
                pausePlaying()
            }
        });
    });

    function setPlaybackSpeed(event) {
        event.preventDefault();
        playbackSpeed = document.getElementById("playbackSpeed").value
        document.getElementById("playbackSpeed").value = playbackSpeed;
    }

    function safeStepForward() {
        if (actualStep >= solutionSteps.length) {
            pausePlaying()
        }
        stepForward();
    }

    function pausePlaying() {
        isRun = false;
        clearInterval(stepInterval)
        document.querySelector('#runButton').innerText = 'Play';
    }

    function stepForward() {
        if (actualStep < solutionSteps.length) {
            queenToggle(solutionSteps[actualStep][0], solutionSteps[actualStep][1]);
            actualStep++;
        }
    }

    function stepBackward() {
        if (actualStep > 0) {
            actualStep--;
            queenToggle(solutionSteps[actualStep][0], solutionSteps[actualStep][1]);
        }
    }

    function resetBoard() {
        actualStep = 0;
        const boardCells = document.querySelectorAll('.cell');
        for (let i = 0; i < boardCells.length; i++) {
            if (boardCells[i].firstChild) {
                boardCells[i].removeChild(boardCells[i].firstChild);
            }
        }
    }

    const setSolutionSteps = async (method) => {
        const loadingElement = document.getElementById('loading');
        loadingElement.style.display = 'block';
        await fetch(`http://localhost:5000/board/${method}/solve`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
            },
        })
            .then((response) => response.json().then(responseSteps => solutionSteps = responseSteps))
            .then(() => loadingElement.style.display = 'none');
    }

    function defineQueen() {
        const queen_img = document.createElement("img");
        queen_img.src = 'fig/queen.png';
        queen_img.classList.add('queen');
        queen_img.style.mixBlendMode = 'multiply';
        return queen_img;
    }

    function initBoard(board) {
        for (let i = 0; i < N * N; i++) {
            const cell = document.createElement('div');
            cell.classList.add('cell', (Math.floor(i / N) + i) % 2 === 0 ? 'white' : 'black');
            board.appendChild(cell);
        }
    }

    function queenToggle(row, col) {
        const boardCells = document.querySelectorAll('.cell');
        const queenIndex = row * N + col;
        console.log(queenIndex)
        if (boardCells[queenIndex].firstChild) {
            boardCells[queenIndex].removeChild(boardCells[queenIndex].firstChild);
        } else {
            boardCells[queenIndex].appendChild(defineQueen());
        }
    }
</script>

</body>
</html>